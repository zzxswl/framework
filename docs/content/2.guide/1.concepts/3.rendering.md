# 渲染模式

浏览器和服务器都可以解释 JavaScript 代码，将 Vue.js 组件呈现为 HTML 元素。这个步骤叫做 **渲染**。Nuxt 支持 **客户端** 和 **通用** 渲染。这两种方法各有利弊，我们将在本节中讨论。

## 客户端渲染

传统的 Vue.js 应用程序是在浏览器（或 **客户端** ）中呈现的。然后，Vue.js 在浏览器下载并解析所有包含创建当前接口的指令的 JavaScript 代码后生成 HTML 元素。
![Users have to wait for the browser to download, parse and execute the JavaScript before seeing the page's content](/img/concepts/rendering/light/csr.svg){.dark:hidden}
![Users have to wait for the browser to download, parse and execute the JavaScript before seeing the page's content](/img/concepts/rendering/dark/csr.svg){.light:hidden}

虽然这种技术可以构建复杂和动态的用户界面，并实现平滑的页面转换，但它有不同的优点和缺点：

### 优点

- **开发速度**：当完全在客户端工作时，我们不必担心代码的服务器兼容性，例如，通过使用像 `window` 对象这样的浏览器专用 API。
- **成本更低:** 运行服务器会增加基础设施成本，因为您需要在支持 JavaScript 的平台上运行。我们可以在任何带有 HTML、CSS 和 JavaScript 文件的静态服务器上托管客户端应用程序。
- **脱机:** 因为代码完全在浏览器中运行，所以即使没有互联网，它也能很好地继续工作。

### Cons

- **Performance**: The user has to wait for the browser to download, parse and run JavaScript files. Depending on the network for the download part and the user's device for the parsing and execution, this can take some time and impact the user's experience.
- **Search Engine Optimization**: Indexing and updating the content delivered via client-side rendering takes more time than with a server-rendered HTML document. This is related to the performance drawback we discussed, as search engine crawlers won't wait for the interface to be fully rendered on their first try to index the page. Your content will take more time to show and update in search results pages with pure client-side rendering.

### Examples

Client-side rendering is a good choice for heavily interactive **web applications** that don't need indexing or frequently use the same users. It can leverage browser caching to skip the download phase on subsequent visits, such as **SaaS, back-office applications, or Online Games**.

## Universal Rendering

When the browser requests a URL with universal (client-side + server-side) rendering enabled, the server returns a fully rendered HTML page to the browser. Whether the page has been generated in advance and cached or is rendered on the fly, at some point, Nuxt has run the JavaScript (Vue.js) code in a server environment, producing an HTML document. Users immediately get the content of our application, contrary to client-side rendering. This step is similar to traditional **server-side rendering** performed by PHP or Ruby applications.

To not lose the benefits of the client-side rendering method, such as dynamic interfaces and pages transitions, the Client loads the javascript code that runs on the Server in the background once the HTML document has been downloaded. The browser interprets it again (hence **Universal rendering**) and Vue.js takes control of the document and enables interactivity.

Making a static page interactive in the browser is called "Hydration."

Universal rendering allows a Nuxt application to provide quick page load times while preserving the benefits of client-side rendering. Furthermore, as the content is already present in the HTML document, crawlers can index it without overhead.

![Users can access the static content when the HTML document is loaded. Hydration then allows page's interactivity](/img/concepts/rendering/light/ssr.svg){.dark:hidden}
![Users can access the static content when the HTML document is loaded. Hydration then allows page's interactivity](/img/concepts/rendering/dark/ssr.svg){.light:hidden}

### Pros

- **Performance**: Users can get immediate access to the page's content because browsers can display static content much faster than JavaScript-generated one. At the same time, Nuxt preserves the interactivity of a web application when the hydration process happens.
- **Search Engine Optimization**: Universal rendering delivers the entire HTML content of the page to the browser as a classic server application. Web crawlers can directly index the page's content, which makes Universal rendering a great choice for any content that you want to index quickly.

### Cons

- **Development constraints:** Server and browser environments don't provide the same APIs, and it can be tricky to write code that can run on both sides seamlessly. Fortunately, Nuxt provides guidelines and specific variables to help you determine where a piece of code is executed.
- **Cost:** A server needs to run to render pages on the fly. This adds a monthly cost like any traditional server. However, the server calls are highly reduced thanks to universal rendering with the browser taking over on client-side navigation.

### Examples

Universal rendering is very versatile and can fit almost any use case, and is especially appropriate for any content-oriented websites: **blogs, marketing websites, portfolios, e-commerce sites, and marketplaces.**

## Summary

Client-side and universal rendering are different strategies to display an interface in a browser.

By default, Nuxt uses **universal rendering** to provide better user experience and performance, and to optimize search engine indexing, but you can switch rendering modes in [one line of configuration](/guide/directory-structure/nuxt.config#ssr).

## Coming in Nuxt 3

In most cases, universal rendering as performed in Nuxt 2 offers a good user and developer experience. However, Nuxt 3 takes universal rendering a step further by introducing hybrid rendering and edge-side rendering.

### Hybrid Rendering

Hybrid rendering allows different caching rules per route and decides how the Server should respond to a new request on a given URL.

At the moment, every page (or **route**) of a Nuxt application must use the same rendering mode, client-side or universal. But in various cases, some pages could be generated at build time, while others should be client-side rendered. For example, think of a content website with an admin section. Every content page should be primarily static and generated once, but the admin section requires registration and behaves more like a dynamic application.

[Read the open RFC discussing implementation and gathering community feedback](https://github.com/nuxt/framework/discussions/560)

### Rendering on CDN edge workers

Traditionally, server-side and universal rendering was only possible using Node.js. Nuxt 3 takes it to another level by directly rendering code in CDN edge workers, reducing latency and costs.

Nitro is the new [server engine](/guide/concepts/server-engine) that powers Nuxt 3. It offers cross-platform support for Node.js, Deno, Workers, and more. Nitro's design is platform-agnostic and allows rendering a Nuxt application at the edge, closer to your users, allowing replication and further optimizations.
